You:



## Overview
You are a code assistant that accepts a golang source file, and a golang test file.
Your goal is to generate unit tests to complement the existing test suite, 
in order to increase the code coverage against the source file.

## Source File
Here is the source file that you will be writing tests against, called mux.go.
Note that we have manually added line numbers for each line of code, to help you understand the code coverage report.
Those numbers are not a part of the original code.
=========
1 // Copyright 2012 The Gorilla Authors. All rights reserved.
2 // Use of this source code is governed by a BSD-style
3 // license that can be found in the LICENSE file.
4 
5 package mux
6 
7 import (
8 	"context"
9 	"errors"
10 	"fmt"
11 	"net/http"
12 	"net/url"
13 	"path"
14 	"regexp"
15 )
16 
17 var (
18 	// ErrMethodMismatch is returned when the method in the request does not match
19 	// the method defined against the route.
20 	ErrMethodMismatch = errors.New("method is not allowed")
21 	// ErrNotFound is returned when no route match is found.
22 	ErrNotFound = errors.New("no matching route was found")
23 	// RegexpCompileFunc aliases regexp.Compile and enables overriding it.
24 	// Do not run this function from init() in importable packages.
25 	// Changing this value is not safe for concurrent use.
26 	RegexpCompileFunc = regexp.Compile
27 	// ErrMetadataKeyNotFound is returned when the specified metadata key is not present in the map
28 	ErrMetadataKeyNotFound = errors.New("key not found in metadata")
29 )
30 
31 // NewRouter returns a new router instance.
32 func NewRouter() *Router {
33 	return &Router{namedRoutes: make(map[string]*Route)}
34 }
35 
36 // Router registers routes to be matched and dispatches a handler.
37 //
38 // It implements the http.Handler interface, so it can be registered to serve
39 // requests:
40 //
41 //	var router = mux.NewRouter()
42 //
43 //	func main() {
44 //	    http.Handle("/", router)
45 //	}
46 //
47 // Or, for Google App Engine, register it in a init() function:
48 //
49 //	func init() {
50 //	    http.Handle("/", router)
51 //	}
52 //
53 // This will send all incoming requests to the router.
54 type Router struct {
55 	// Configurable Handler to be used when no route matches.
56 	// This can be used to render your own 404 Not Found errors.
57 	NotFoundHandler http.Handler
58 
59 	// Configurable Handler to be used when the request method does not match the route.
60 	// This can be used to render your own 405 Method Not Allowed errors.
61 	MethodNotAllowedHandler http.Handler
62 
63 	// Routes to be matched, in order.
64 	routes []*Route
65 
66 	// Routes by name for URL building.
67 	namedRoutes map[string]*Route
68 
69 	// If true, do not clear the request context after handling the request.
70 	//
71 	// Deprecated: No effect, since the context is stored on the request itself.
72 	KeepContext bool
73 
74 	// Slice of middlewares to be called after a match is found
75 	middlewares []middleware
76 
77 	// configuration shared with Route
78 	routeConf
79 }
80 
81 // common route configuration shared between Router and Route
82 type routeConf struct {
83 	// If true, "/path/foo%2Fbar/to" will match the path "/path/{var}/to"
84 	useEncodedPath bool
85 
86 	// If true, when the path pattern is "/path/", accessing "/path" will
87 	// redirect to the former and vice versa.
88 	strictSlash bool
89 
90 	// If true, when the path pattern is "/path//to", accessing "/path//to"
91 	// will not redirect
92 	skipClean bool
93 
94 	// If true, the http.Request context will not contain the Route.
95 	omitRouteFromContext bool
96 
97 	// if true, the the http.Request context will not contain the router
98 	omitRouterFromContext bool
99 
100 	// Manager for the variables from host and path.
101 	regexp routeRegexpGroup
102 
103 	// List of matchers.
104 	matchers []matcher
105 
106 	// The scheme used when building URLs.
107 	buildScheme string
108 
109 	buildVarsFunc BuildVarsFunc
110 }
111 
112 // returns an effective deep copy of routeConf
113 func copyRouteConf(r routeConf) routeConf {
114 	c := r
115 
116 	if r.regexp.path != nil {
117 		c.regexp.path = copyRouteRegexp(r.regexp.path)
118 	}
119 
120 	if r.regexp.host != nil {
121 		c.regexp.host = copyRouteRegexp(r.regexp.host)
122 	}
123 
124 	c.regexp.queries = make([]*routeRegexp, 0, len(r.regexp.queries))
125 	for _, q := range r.regexp.queries {
126 		c.regexp.queries = append(c.regexp.queries, copyRouteRegexp(q))
127 	}
128 
129 	c.matchers = make([]matcher, len(r.matchers))
130 	copy(c.matchers, r.matchers)
131 
132 	return c
133 }
134 
135 func copyRouteRegexp(r *routeRegexp) *routeRegexp {
136 	c := *r
137 	return &c
138 }
139 
140 // Match attempts to match the given request against the router's registered routes.
141 //
142 // If the request matches a route of this router or one of its subrouters the Route,
143 // Handler, and Vars fields of the the match argument are filled and this function
144 // returns true.
145 //
146 // If the request does not match any of this router's or its subrouters' routes
147 // then this function returns false. If available, a reason for the match failure
148 // will be filled in the match argument's MatchErr field. If the match failure type
149 // (eg: not found) has a registered handler, the handler is assigned to the Handler
150 // field of the match argument.
151 func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
152 	for _, route := range r.routes {
153 		if route.Match(req, match) {
154 			// Build middleware chain if no error was found
155 			if match.MatchErr == nil {
156 				for i := len(r.middlewares) - 1; i >= 0; i-- {
157 					match.Handler = r.middlewares[i].Middleware(match.Handler)
158 				}
159 			}
160 			return true
161 		}
162 	}
163 
164 	if match.MatchErr == ErrMethodMismatch {
165 		if r.MethodNotAllowedHandler != nil {
166 			match.Handler = r.MethodNotAllowedHandler
167 			return true
168 		}
169 
170 		return false
171 	}
172 
173 	// Closest match for a router (includes sub-routers)
174 	if r.NotFoundHandler != nil {
175 		match.Handler = r.NotFoundHandler
176 		match.MatchErr = ErrNotFound
177 		return true
178 	}
179 
180 	match.MatchErr = ErrNotFound
181 	return false
182 }
183 
184 // ServeHTTP dispatches the handler registered in the matched route.
185 //
186 // When there is a match, the route variables can be retrieved calling
187 // mux.Vars(request).
188 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
189 	if !r.skipClean {
190 		path := req.URL.Path
191 		if r.useEncodedPath {
192 			path = req.URL.EscapedPath()
193 		}
194 		// Clean path to canonical form and redirect.
195 		if p := cleanPath(path); p != path {
196 			w.Header().Set("Location", replaceURLPath(req.URL, p))
197 			w.WriteHeader(http.StatusMovedPermanently)
198 			return
199 		}
200 	}
201 	var match RouteMatch
202 	var handler http.Handler
203 	if r.Match(req, &match) {
204 		handler = match.Handler
205 		if handler != nil {
206 			// Populate context for custom handlers
207 			if r.omitRouteFromContext {
208 				// Only populate the match vars (if any) into the context.
209 				req = requestWithVars(req, match.Vars)
210 			} else {
211 				req = requestWithRouteAndVars(req, match.Route, match.Vars)
212 			}
213 
214 			if !r.omitRouterFromContext {
215 				req = requestWithRouter(req, r)
216 			}
217 		}
218 	}
219 
220 	if handler == nil && match.MatchErr == ErrMethodMismatch {
221 		handler = methodNotAllowedHandler()
222 	}
223 
224 	if handler == nil {
225 		handler = http.NotFoundHandler()
226 	}
227 
228 	handler.ServeHTTP(w, req)
229 }
230 
231 // Get returns a route registered with the given name.
232 func (r *Router) Get(name string) *Route {
233 	return r.namedRoutes[name]
234 }
235 
236 // GetRoute returns a route registered with the given name. This method
237 // was renamed to Get() and remains here for backwards compatibility.
238 func (r *Router) GetRoute(name string) *Route {
239 	return r.namedRoutes[name]
240 }
241 
242 // StrictSlash defines the trailing slash behavior for new routes. The initial
243 // value is false.
244 //
245 // When true, if the route path is "/path/", accessing "/path" will perform a redirect
246 // to the former and vice versa. In other words, your application will always
247 // see the path as specified in the route.
248 //
249 // When false, if the route path is "/path", accessing "/path/" will not match
250 // this route and vice versa.
251 //
252 // The redirect is a HTTP 301 (Moved Permanently). Note that when this is set for
253 // routes with a non-idempotent method (e.g. POST, PUT), the subsequent redirected
254 // request will be made as a GET by most clients. Use middleware or client settings
255 // to modify this behaviour as needed.
256 //
257 // Special case: when a route sets a path prefix using the PathPrefix() method,
258 // strict slash is ignored for that route because the redirect behavior can't
259 // be determined from a prefix alone. However, any subrouters created from that
260 // route inherit the original StrictSlash setting.
261 func (r *Router) StrictSlash(value bool) *Router {
262 	r.strictSlash = value
263 	return r
264 }
265 
266 // SkipClean defines the path cleaning behaviour for new routes. The initial
267 // value is false. Users should be careful about which routes are not cleaned
268 //
269 // When true, if the route path is "/path//to", it will remain with the double
270 // slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/
271 //
272 // When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will
273 // become /fetch/http/xkcd.com/534
274 func (r *Router) SkipClean(value bool) *Router {
275 	r.skipClean = value
276 	return r
277 }
278 
279 // OmitRouteFromContext defines the behavior of omitting the Route from the
280 //
281 //	http.Request context.
282 //
283 // CurrentRoute will yield nil with this option.
284 func (r *Router) OmitRouteFromContext(value bool) *Router {
285 	r.omitRouteFromContext = value
286 	return r
287 }
288 
289 // OmitRouterFromContext defines the behavior of omitting the Router from the
290 // http.Request context.
291 //
292 // RouterFromRequest will yield nil with this option.
293 func (r *Router) OmitRouterFromContext(value bool) *Router {
294 	r.omitRouterFromContext = value
295 	return r
296 }
297 
298 // UseEncodedPath tells the router to match the encoded original path
299 // to the routes.
300 // For eg. "/path/foo%2Fbar/to" will match the path "/path/{var}/to".
301 //
302 // If not called, the router will match the unencoded path to the routes.
303 // For eg. "/path/foo%2Fbar/to" will match the path "/path/foo/bar/to"
304 func (r *Router) UseEncodedPath() *Router {
305 	r.useEncodedPath = true
306 	return r
307 }
308 
309 // ----------------------------------------------------------------------------
310 // Route factories
311 // ----------------------------------------------------------------------------
312 
313 // NewRoute registers an empty route.
314 func (r *Router) NewRoute() *Route {
315 	// initialize a route with a copy of the parent router's configuration
316 	route := &Route{routeConf: copyRouteConf(r.routeConf), namedRoutes: r.namedRoutes}
317 	r.routes = append(r.routes, route)
318 	return route
319 }
320 
321 // Name registers a new route with a name.
322 // See Route.Name().
323 func (r *Router) Name(name string) *Route {
324 	return r.NewRoute().Name(name)
325 }
326 
327 // Handle registers a new route with a matcher for the URL path.
328 // See Route.Path() and Route.Handler().
329 func (r *Router) Handle(path string, handler http.Handler) *Route {
330 	return r.NewRoute().Path(path).Handler(handler)
331 }
332 
333 // HandleFunc registers a new route with a matcher for the URL path.
334 // See Route.Path() and Route.HandlerFunc().
335 func (r *Router) HandleFunc(path string, f func(http.ResponseWriter,
336 	*http.Request)) *Route {
337 	return r.NewRoute().Path(path).HandlerFunc(f)
338 }
339 
340 // Headers registers a new route with a matcher for request header values.
341 // See Route.Headers().
342 func (r *Router) Headers(pairs ...string) *Route {
343 	return r.NewRoute().Headers(pairs...)
344 }
345 
346 // Host registers a new route with a matcher for the URL host.
347 // See Route.Host().
348 func (r *Router) Host(tpl string) *Route {
349 	return r.NewRoute().Host(tpl)
350 }
351 
352 // MatcherFunc registers a new route with a custom matcher function.
353 // See Route.MatcherFunc().
354 func (r *Router) MatcherFunc(f MatcherFunc) *Route {
355 	return r.NewRoute().MatcherFunc(f)
356 }
357 
358 // Methods registers a new route with a matcher for HTTP methods.
359 // See Route.Methods().
360 func (r *Router) Methods(methods ...string) *Route {
361 	return r.NewRoute().Methods(methods...)
362 }
363 
364 // Path registers a new route with a matcher for the URL path.
365 // See Route.Path().
366 func (r *Router) Path(tpl string) *Route {
367 	return r.NewRoute().Path(tpl)
368 }
369 
370 // PathPrefix registers a new route with a matcher for the URL path prefix.
371 // See Route.PathPrefix().
372 func (r *Router) PathPrefix(tpl string) *Route {
373 	return r.NewRoute().PathPrefix(tpl)
374 }
375 
376 // Queries registers a new route with a matcher for URL query values.
377 // See Route.Queries().
378 func (r *Router) Queries(pairs ...string) *Route {
379 	return r.NewRoute().Queries(pairs...)
380 }
381 
382 // Schemes registers a new route with a matcher for URL schemes.
383 // See Route.Schemes().
384 func (r *Router) Schemes(schemes ...string) *Route {
385 	return r.NewRoute().Schemes(schemes...)
386 }
387 
388 // BuildVarsFunc registers a new route with a custom function for modifying
389 // route variables before building a URL.
390 func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
391 	return r.NewRoute().BuildVarsFunc(f)
392 }
393 
394 // Walk walks the router and all its sub-routers, calling walkFn for each route
395 // in the tree. The routes are walked in the order they were added. Sub-routers
396 // are explored depth-first.
397 func (r *Router) Walk(walkFn WalkFunc) error {
398 	return r.walk(walkFn, []*Route{})
399 }
400 
401 // SkipRouter is used as a return value from WalkFuncs to indicate that the
402 // router that walk is about to descend down to should be skipped.
403 var SkipRouter = errors.New("skip this router")
404 
405 // WalkFunc is the type of the function called for each route visited by Walk.
406 // At every invocation, it is given the current route, and the current router,
407 // and a list of ancestor routes that lead to the current route.
408 type WalkFunc func(route *Route, router *Router, ancestors []*Route) error
409 
410 func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
411 	for _, t := range r.routes {
412 		err := walkFn(t, r, ancestors)
413 		if err == SkipRouter {
414 			continue
415 		}
416 		if err != nil {
417 			return err
418 		}
419 		for _, sr := range t.matchers {
420 			if h, ok := sr.(*Router); ok {
421 				ancestors = append(ancestors, t)
422 				err := h.walk(walkFn, ancestors)
423 				if err != nil {
424 					return err
425 				}
426 				ancestors = ancestors[:len(ancestors)-1]
427 			}
428 		}
429 		if h, ok := t.handler.(*Router); ok {
430 			ancestors = append(ancestors, t)
431 			err := h.walk(walkFn, ancestors)
432 			if err != nil {
433 				return err
434 			}
435 			ancestors = ancestors[:len(ancestors)-1]
436 		}
437 	}
438 	return nil
439 }
440 
441 // ----------------------------------------------------------------------------
442 // Context
443 // ----------------------------------------------------------------------------
444 
445 // RouteMatch stores information about a matched route.
446 type RouteMatch struct {
447 	Route   *Route
448 	Handler http.Handler
449 	Vars    map[string]string
450 
451 	// MatchErr is set to appropriate matching error
452 	// It is set to ErrMethodMismatch if there is a mismatch in
453 	// the request method and route method
454 	MatchErr error
455 }
456 
457 type contextKey int
458 
459 const (
460 	varsKey contextKey = iota
461 	routeKey
462 	routerKey
463 )
464 
465 // Vars returns the route variables for the current request, if any.
466 func Vars(r *http.Request) map[string]string {
467 	if rv := r.Context().Value(varsKey); rv != nil {
468 		return rv.(map[string]string)
469 	}
470 	return nil
471 }
472 
473 // CurrentRoute returns the matched route for the current request, if any.
474 // This only works when called inside the handler of the matched route
475 // because the matched route is stored in the request context which is cleared
476 // after the handler returns.
477 func CurrentRoute(r *http.Request) *Route {
478 	if rv := r.Context().Value(routeKey); rv != nil {
479 		return rv.(*Route)
480 	}
481 	return nil
482 }
483 
484 func CurrentRouter(r *http.Request) *Router {
485 	if rv := r.Context().Value(routerKey); rv != nil {
486 		return rv.(*Router)
487 	}
488 	return nil
489 }
490 
491 // requestWithVars adds the matched vars to the request ctx.
492 // It shortcuts the operation when the vars are empty.
493 func requestWithVars(r *http.Request, vars map[string]string) *http.Request {
494 	if len(vars) == 0 {
495 		return r
496 	}
497 	ctx := context.WithValue(r.Context(), varsKey, vars)
498 	return r.WithContext(ctx)
499 }
500 
501 // requestWithRouteAndVars adds the matched route and vars to the request ctx.
502 // It saves extra allocations in cloning the request once and skipping the
503 //
504 //	population of empty vars, which in turn mux.Vars can handle gracefully.
505 func requestWithRouteAndVars(r *http.Request, route *Route, vars map[string]string) *http.Request {
506 	ctx := context.WithValue(r.Context(), routeKey, route)
507 	if len(vars) > 0 {
508 		ctx = context.WithValue(ctx, varsKey, vars)
509 	}
510 	return r.WithContext(ctx)
511 }
512 
513 func requestWithRouter(r *http.Request, router *Router) *http.Request {
514 	ctx := context.WithValue(r.Context(), routerKey, router)
515 	return r.WithContext(ctx)
516 }
517 
518 // ----------------------------------------------------------------------------
519 // Helpers
520 // ----------------------------------------------------------------------------
521 
522 // cleanPath returns the canonical path for p, eliminating . and .. elements.
523 // Borrowed from the net/http package.
524 func cleanPath(p string) string {
525 	if p == "" {
526 		return "/"
527 	}
528 	if p[0] != '/' {
529 		p = "/" + p
530 	}
531 	np := path.Clean(p)
532 	// path.Clean removes trailing slash except for root;
533 	// put the trailing slash back if necessary.
534 	if p[len(p)-1] == '/' && np != "/" {
535 		np += "/"
536 	}
537 
538 	return np
539 }
540 
541 // replaceURLPath prints an url.URL with a different path.
542 func replaceURLPath(u *url.URL, p string) string {
543 	// Operate on a copy of the request url.
544 	u2 := *u
545 	u2.Path = p
546 	return u2.String()
547 }
548 
549 // uniqueVars returns an error if two slices contain duplicated strings.
550 func uniqueVars(s1, s2 []string) error {
551 	for _, v1 := range s1 {
552 		for _, v2 := range s2 {
553 			if v1 == v2 {
554 				return fmt.Errorf("mux: duplicated route variable %q", v2)
555 			}
556 		}
557 	}
558 	return nil
559 }
560 
561 // checkPairs returns the count of strings passed in, and an error if
562 // the count is not an even number.
563 func checkPairs(pairs ...string) (int, error) {
564 	length := len(pairs)
565 	if length%2 != 0 {
566 		return length, fmt.Errorf(
567 			"mux: number of parameters must be multiple of 2, got %v", pairs)
568 	}
569 	return length, nil
570 }
571 
572 // mapFromPairsToString converts variadic string parameters to a
573 // string to string map.
574 func mapFromPairsToString(pairs ...string) (map[string]string, error) {
575 	length, err := checkPairs(pairs...)
576 	if err != nil {
577 		return nil, err
578 	}
579 	m := make(map[string]string, length/2)
580 	for i := 0; i < length; i += 2 {
581 		m[pairs[i]] = pairs[i+1]
582 	}
583 	return m, nil
584 }
585 
586 // mapFromPairsToRegex converts variadic string parameters to a
587 // string to regex map.
588 func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
589 	length, err := checkPairs(pairs...)
590 	if err != nil {
591 		return nil, err
592 	}
593 	m := make(map[string]*regexp.Regexp, length/2)
594 	for i := 0; i < length; i += 2 {
595 		regex, err := RegexpCompileFunc(pairs[i+1])
596 		if err != nil {
597 			return nil, err
598 		}
599 		m[pairs[i]] = regex
600 	}
601 	return m, nil
602 }
603 
604 // matchInArray returns true if the given string value is in the array.
605 func matchInArray(arr []string, value string) bool {
606 	for _, v := range arr {
607 		if v == value {
608 			return true
609 		}
610 	}
611 	return false
612 }
613 
614 // matchMapWithString returns true if the given key/value pairs exist in a given map.
615 func matchMapWithString(toCheck map[string]string, toMatch map[string][]string, canonicalKey bool) bool {
616 	for k, v := range toCheck {
617 		// Check if key exists.
618 		if canonicalKey {
619 			k = http.CanonicalHeaderKey(k)
620 		}
621 		if values := toMatch[k]; values == nil {
622 			return false
623 		} else if v != "" {
624 			// If value was defined as an empty string we only check that the
625 			// key exists. Otherwise we also check for equality.
626 			valueExists := false
627 			for _, value := range values {
628 				if v == value {
629 					valueExists = true
630 					break
631 				}
632 			}
633 			if !valueExists {
634 				return false
635 			}
636 		}
637 	}
638 	return true
639 }
640 
641 // matchMapWithRegex returns true if the given key/value pairs exist in a given map compiled against
642 // the given regex
643 func matchMapWithRegex(toCheck map[string]*regexp.Regexp, toMatch map[string][]string, canonicalKey bool) bool {
644 	for k, v := range toCheck {
645 		// Check if key exists.
646 		if canonicalKey {
647 			k = http.CanonicalHeaderKey(k)
648 		}
649 		if values := toMatch[k]; values == nil {
650 			return false
651 		} else if v != nil {
652 			// If value was defined as an empty string we only check that the
653 			// key exists. Otherwise we also check for equality.
654 			valueExists := false
655 			for _, value := range values {
656 				if v.MatchString(value) {
657 					valueExists = true
658 					break
659 				}
660 			}
661 			if !valueExists {
662 				return false
663 			}
664 		}
665 	}
666 	return true
667 }
668 
669 // methodNotAllowed replies to the request with an HTTP status code 405.
670 func methodNotAllowed(w http.ResponseWriter, r *http.Request) {
671 	w.WriteHeader(http.StatusMethodNotAllowed)
672 }
673 
674 // methodNotAllowedHandler returns a simple request handler
675 // that replies to each request with a status code 405.
676 func methodNotAllowedHandler() http.Handler { return http.HandlerFunc(methodNotAllowed) }
677 
=========

## Additional Includes
The following is a set of included files used as context for the source code above.
This is usually included libraries needed as context to write better tests:
======
// Copyright 2012 The Gorilla Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mux

import (
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"regexp"
	"strings"
)

// Route stores information to match a request and build URLs.
type Route struct {
	// Request handler for the route.
	handler http.Handler
	// If true, this route never matches: it is only used to build URLs.
	buildOnly bool
	// The name used to build URLs.
	name string
	// Error resulted from building a route.
	err error

	// The meta data associated with this route
	metadata map[any]any

	// "global" reference to all named routes
	namedRoutes map[string]*Route

	// route specific middleware
	middlewares []middleware

	// config possibly passed in from Router
	routeConf
}

// SkipClean reports whether path cleaning is enabled for this route via
// Router.SkipClean.
func (r *Route) SkipClean() bool {
	return r.skipClean
}

// Match matches the route against the request.
func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
	if r.buildOnly || r.err != nil {
		return false
	}

	var matchErr error

	// Match everything.
	for _, m := range r.matchers {
		if matched := m.Match(req, match); !matched {
			if _, ok := m.(methodMatcher); ok {
				matchErr = ErrMethodMismatch
				continue
			}

			// Multiple routes may share the same path but use different HTTP methods. For instance:
			// Route 1: POST "/users/{id}".
			// Route 2: GET "/users/{id}", parameters: "id": "[0-9]+".
			//
			// The router must handle these cases correctly. For a GET request to "/users/abc" with "id" as "-2",
			// The router should return a "Not Found" error as no route fully matches this request.
			if rr, ok := m.(*routeRegexp); ok {
				if rr.regexpType == regexpTypeQuery {
					matchErr = ErrNotFound
					break
				}
			}

			// Ignore ErrNotFound errors. These errors arise from match call
			// to Subrouters.
			//
			// This prevents subsequent matching subrouters from failing to
			// run middleware. If not ignored, the middleware would see a
			// non-nil MatchErr and be skipped, even when there was a
			// matching route.
			if match.MatchErr == ErrNotFound {
				match.MatchErr = nil
			}

			matchErr = nil // nolint:ineffassign
			return false
		}
	}

	if matchErr != nil {
		match.MatchErr = matchErr
		return false
	}

	if match.MatchErr != nil && r.handler != nil {
		// We found a route which matches request method, clear MatchErr
		match.MatchErr = nil
		// Then override the mis-matched handler
		match.Handler = r.handler
	}

	// Yay, we have a match. Let's collect some info about it.
	if match.Route == nil {
		match.Route = r
	}
	if match.Handler == nil {
		match.Handler = r.GetHandlerWithMiddlewares()
	}

	// Set variables.
	r.regexp.setMatch(req, match, r)
	return true
}

// ----------------------------------------------------------------------------
// Route attributes
// ----------------------------------------------------------------------------

// GetError returns an error resulted from building the route, if any.
func (r *Route) GetError() error {
	return r.err
}

// BuildOnly sets the route to never match: it is only used to build URLs.
func (r *Route) BuildOnly() *Route {
	r.buildOnly = true
	return r
}

// MetaData -------------------------------------------------------------------

// Metadata is used to set metadata on a route
func (r *Route) Metadata(key any, value any) *Route {
	if r.metadata == nil {
		r.metadata = make(map[any]any)
	}

	r.metadata[key] = value
	return r
}

// GetMetadata returns the metadata map for route
func (r *Route) GetMetadata() map[any]any {
	return r.metadata
}

// MetadataContains returns whether or not the key is present in the metadata map
func (r *Route) MetadataContains(key any) bool {
	_, ok := r.metadata[key]
	return ok
}

// GetMetadataValue returns the value of a specific key in the metadata map. If the key is not present in the map mux.ErrMetadataKeyNotFound is returned
func (r *Route) GetMetadataValue(key any) (any, error) {
	value, ok := r.metadata[key]
	if !ok {
		return nil, ErrMetadataKeyNotFound
	}

	return value, nil
}

// GetMetadataValueOr returns the value of a specific key in the metadata map. If the key is not present in the metadata the fallback value is returned
func (r *Route) GetMetadataValueOr(key any, fallbackValue any) any {
	value, ok := r.metadata[key]
	if !ok {
		return fallbackValue
	}

	return value
}

// Handler --------------------------------------------------------------------

// Handler sets a handler for the route.
func (r *Route) Handler(handler http.Handler) *Route {
	if r.err == nil {
		r.handler = handler
	}
	return r
}

// HandlerFunc sets a handler function for the route.
func (r *Route) HandlerFunc(f func(http.ResponseWriter, *http.Request)) *Route {
	return r.Handler(http.HandlerFunc(f))
}

// GetHandler returns the handler for the route, if any.
func (r *Route) GetHandler() http.Handler {
	return r.handler
}

// GetHandlerWithMiddleware returns the route handler wrapped in the assigned middlewares.
// If no middlewares are specified, just the handler, if any, is returned.
func (r *Route) GetHandlerWithMiddlewares() http.Handler {
	handler := r.handler

	if handler != nil && len(r.middlewares) > 0 {
		for i := len(r.middlewares) - 1; i >= 0; i-- {
			handler = r.middlewares[i].Middleware(handler)
		}
	}

	return handler
}

// Name -----------------------------------------------------------------------

// Name sets the name for the route, used to build URLs.
// It is an error to call Name more than once on a route.
func (r *Route) Name(name string) *Route {
	if r.name != "" {
		r.err = fmt.Errorf("mux: route already has name %q, can't set %q",
			r.name, name)
	}
	if r.err == nil {
		r.name = name
		r.namedRoutes[name] = r
	}
	return r
}

// GetName returns the name for the route, if any.
func (r *Route) GetName() string {
	return r.name
}

// ----------------------------------------------------------------------------
// Matchers
// ----------------------------------------------------------------------------

// matcher types try to match a request.
type matcher interface {
	Match(*http.Request, *RouteMatch) bool
}

// addMatcher adds a matcher to the route.
func (r *Route) addMatcher(m matcher) *Route {
	if r.err == nil {
		r.matchers = append(r.matchers, m)
	}
	return r
}

// addRegexpMatcher adds a host or path matcher and builder to a route.
func (r *Route) addRegexpMatcher(tpl string, typ regexpType) error {
	if r.err != nil {
		return r.err
	}
	if typ == regexpTypePath || typ == regexpTypePrefix {
		if len(tpl) > 0 && tpl[0] != '/' {
			return fmt.Errorf("mux: path must start with a slash, got %q", tpl)
		}
		if r.regexp.path != nil {
			tpl = strings.TrimRight(r.regexp.path.template, "/") + tpl
		}
	}
	rr, err := newRouteRegexp(tpl, typ, routeRegexpOptions{
		strictSlash:    r.strictSlash,
		useEncodedPath: r.useEncodedPath,
	})
	if err != nil {
		return err
	}
	for _, q := range r.regexp.queries {
		if err = uniqueVars(rr.varsN, q.varsN); err != nil {
			return err
		}
	}
	if typ == regexpTypeHost {
		if r.regexp.path != nil {
			if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
				return err
			}
		}
		r.regexp.host = rr
	} else {
		if r.regexp.host != nil {
			if err = uniqueVars(rr.varsN, r.regexp.host.varsN); err != nil {
				return err
			}
		}
		if typ == regexpTypeQuery {
			r.regexp.queries = append(r.regexp.queries, rr)
		} else {
			r.regexp.path = rr
		}
	}
	r.addMatcher(rr)
	return nil
}

// Headers --------------------------------------------------------------------

// headerMatcher matches the request against header values.
type headerMatcher map[string]string

func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
	return matchMapWithString(m, r.Header, true)
}

// Headers adds a matcher for request header values.
// It accepts a sequence of key/value pairs to be matched. For example:
//
//	r := mux.NewRouter().NewRoute()
//	r.Headers("Content-Type", "application/json",
//	          "X-Requested-With", "XMLHttpRequest")
//
// The above route will only match if both request header values match.
// If the value is an empty string, it will match any value if the key is set.
func (r *Route) Headers(pairs ...string) *Route {
	if r.err == nil {
		var headers map[string]string
		headers, r.err = mapFromPairsToString(pairs...)
		return r.addMatcher(headerMatcher(headers))
	}
	return r
}

// headerRegexMatcher matches the request against the route given a regex for the header
type headerRegexMatcher map[string]*regexp.Regexp

func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
	return matchMapWithRegex(m, r.Header, true)
}

// HeadersRegexp accepts a sequence of key/value pairs, where the value has regex
// support. For example:
//
//	r := mux.NewRouter().NewRoute()
//	r.HeadersRegexp("Content-Type", "application/(text|json)",
//	          "X-Requested-With", "XMLHttpRequest")
//
// The above route will only match if both the request header matches both regular expressions.
// If the value is an empty string, it will match any value if the key is set.
// Use the start and end of string anchors (^ and $) to match an exact value.
func (r *Route) HeadersRegexp(pairs ...string) *Route {
	if r.err == nil {
		var headers map[string]*regexp.Regexp
		headers, r.err = mapFromPairsToRegex(pairs...)
		return r.addMatcher(headerRegexMatcher(headers))
	}
	return r
}

// Host -----------------------------------------------------------------------

// Host adds a matcher for the URL host.
// It accepts a template with zero or more URL variables enclosed by {}.
// Variables can define an optional regexp pattern to be matched:
//
// - {name} matches anything until the next dot.
//
// - {name:pattern} matches the given regexp pattern.
//
// For example:
//
//	r := mux.NewRouter().NewRoute()
//	r.Host("www.example.com")
//	r.Host("{subdomain}.domain.com")
//	r.Host("{subdomain:[a-z]+}.domain.com")
//
// Variable names must be unique in a given route. They can be retrieved
// calling mux.Vars(request).
func (r *Route) Host(tpl string) *Route {
	r.err = r.addRegexpMatcher(tpl, regexpTypeHost)
	return r
}

// MatcherFunc ----------------------------------------------------------------

// MatcherFunc is the function signature used by custom matchers.
type MatcherFunc func(*http.Request, *RouteMatch) bool

// Match returns the match for a given request.
func (m MatcherFunc) Match(r *http.Request, match *RouteMatch) bool {
	return m(r, match)
}

// MatcherFunc adds a custom function to be used as request matcher.
func (r *Route) MatcherFunc(f MatcherFunc) *Route {
	return r.addMatcher(f)
}

// Methods --------------------------------------------------------------------

// methodMatcher matches the request against HTTP methods.
type methodMatcher []string

func (m methodMatcher) Match(r *http.Request, match *RouteMatch) bool {
	return matchInArray(m, r.Method)
}

// Methods adds a matcher for HTTP methods.
// It accepts a sequence of one or more methods to be matched, e.g.:
// "GET", "POST", "PUT".
func (r *Route) Methods(methods ...string) *Route {
	for k, v := range methods {
		methods[k] = strings.ToUpper(v)
	}
	return r.addMatcher(methodMatcher(methods))
}

// Path -----------------------------------------------------------------------

// Path adds a matcher for the URL path.
// It accepts a template with zero or more URL variables enclosed by {}. The
// template must start with a "/".
// Variables can define an optional regexp pattern to be matched:
//
// - {name} matches anything until the next slash.
//
// - {name:pattern} matches the given regexp pattern.
//
// For example:
//
//	r := mux.NewRouter().NewRoute()
//	r.Path("/products/").Handler(ProductsHandler)
//	r.Path("/products/{key}").Handler(ProductsHandler)
//	r.Path("/articles/{category}/{id:[0-9]+}").
//	  Handler(ArticleHandler)
//
// Variable names must be unique in a given route. They can be retrieved
// calling mux.Vars(request).
func (r *Route) Path(tpl string) *Route {
	r.err = r.addRegexpMatcher(tpl, regexpTypePath)
	return r
}

// PathPrefix -----------------------------------------------------------------

// PathPrefix adds a matcher for the URL path prefix. This matches if the given
// template is a prefix of the full URL path. See Route.Path() for details on
// the tpl argument.
//
// Note that it does not treat slashes specially ("/foobar/" will be matched by
// the prefix "/foo") so you may want to use a trailing slash here.
//
// Also note that the setting of Router.StrictSlash() has no effect on routes
// with a PathPrefix matcher.
func (r *Route) PathPrefix(tpl string) *Route {
	r.err = r.addRegexpMatcher(tpl, regexpTypePrefix)
	return r
}

// Query ----------------------------------------------------------------------

// Queries adds a matcher for URL query values.
// It accepts a sequence of key/value pairs. Values may define variables.
// For example:
//
//	r := mux.NewRouter().NewRoute()
//	r.Queries("foo", "bar", "id", "{id:[0-9]+}")
//
// The above route will only match if the URL contains the defined queries
// values, e.g.: ?foo=bar&id=42.
//
// If the value is an empty string, it will match any value if the key is set.
//
// Variables can define an optional regexp pattern to be matched:
//
// - {name} matches anything until the next slash.
//
// - {name:pattern} matches the given regexp pattern.
func (r *Route) Queries(pairs ...string) *Route {
	length := len(pairs)
	if length%2 != 0 {
		r.err = fmt.Errorf(
			"mux: number of parameters must be multiple of 2, got %v", pairs)
		return nil
	}
	for i := 0; i < length; i += 2 {
		if r.err = r.addRegexpMatcher(pairs[i]+"="+pairs[i+1], regexpTypeQuery); r.err != nil {
			return r
		}
	}

	return r
}

// Schemes --------------------------------------------------------------------

// schemeMatcher matches the request against URL schemes.
type schemeMatcher []string

func (m schemeMatcher) Match(r *http.Request, match *RouteMatch) bool {
	scheme := r.URL.Scheme
	// https://golang.org/pkg/net/http/#Request
	// "For [most] server requests, fields other than Path and RawQuery will be
	// empty."
	// Since we're an http muxer, the scheme is either going to be http or https
	// though, so we can just set it based on the tls termination state.
	if scheme == "" {
		if r.TLS == nil {
			scheme = "http"
		} else {
			scheme = "https"
		}
	}
	return matchInArray(m, scheme)
}

// Schemes adds a matcher for URL schemes.
// It accepts a sequence of schemes to be matched, e.g.: "http", "https".
// If the request's URL has a scheme set, it will be matched against.
// Generally, the URL scheme will only be set if a previous handler set it,
// such as the ProxyHeaders handler from gorilla/handlers.
// If unset, the scheme will be determined based on the request's TLS
// termination state.
// The first argument to Schemes will be used when constructing a route URL.
func (r *Route) Schemes(schemes ...string) *Route {
	for k, v := range schemes {
		schemes[k] = strings.ToLower(v)
	}
	if len(schemes) > 0 {
		r.buildScheme = schemes[0]
	}
	return r.addMatcher(schemeMatcher(schemes))
}

// BuildVarsFunc --------------------------------------------------------------

// BuildVarsFunc is the function signature used by custom build variable
// functions (which can modify route variables before a route's URL is built).
type BuildVarsFunc func(map[string]string) map[string]string

// BuildVarsFunc adds a custom function to be used to modify build variables
// before a route's URL is built.
func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
	if r.buildVarsFunc != nil {
		// compose the old and new functions
		old := r.buildVarsFunc
		r.buildVarsFunc = func(m map[string]string) map[string]string {
			return f(old(m))
		}
	} else {
		r.buildVarsFunc = f
	}
	return r
}

// Subrouter ------------------------------------------------------------------

// Subrouter creates a subrouter for the route.
//
// It will test the inner routes only if the parent route matched. For example:
//
//	r := mux.NewRouter().NewRoute()
//	s := r.Host("www.example.com").Subrouter()
//	s.HandleFunc("/products/", ProductsHandler)
//	s.HandleFunc("/products/{key}", ProductHandler)
//	s.HandleFunc("/articles/{category}/{id:[0-9]+}"), ArticleHandler)
//
// Here, the routes registered in the subrouter won't be tested if the host
// doesn't match.
func (r *Route) Subrouter() *Router {
	// initialize a subrouter with a copy of the parent route's configuration
	router := &Router{routeConf: copyRouteConf(r.routeConf), namedRoutes: r.namedRoutes}
	r.addMatcher(router)
	return router
}

// ----------------------------------------------------------------------------
// URL building
// ----------------------------------------------------------------------------

// URL builds a URL for the route.
//
// It accepts a sequence of key/value pairs for the route variables. For
// example, given this route:
//
//	r := mux.NewRouter()
//	r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).
//	  Name("article")
//
// ...a URL for it can be built using:
//
//	url, err := r.Get("article").URL("category", "technology", "id", "42")
//
// ...which will return an url.URL with the following path:
//
//	"/articles/technology/42"
//
// This also works for host variables:
//
//	r := mux.NewRouter()
//	r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).
//	  Host("{subdomain}.domain.com").
//	  Name("article")
//
//	// url.String() will be "http://news.domain.com/articles/technology/42"
//	url, err := r.Get("article").URL("subdomain", "news",
//	                                 "category", "technology",
//	                                 "id", "42")
//
// The scheme of the resulting url will be the first argument that was passed to Schemes:
//
//	// url.String() will be "https://example.com"
//	r := mux.NewRouter().NewRoute()
//	url, err := r.Host("example.com")
//	             .Schemes("https", "http").URL()
//
// All variables defined in the route are required, and their values must
// conform to the corresponding patterns.
func (r *Route) URL(pairs ...string) (*url.URL, error) {
	if r.err != nil {
		return nil, r.err
	}
	values, err := r.prepareVars(pairs...)
	if err != nil {
		return nil, err
	}
	var scheme, host, path string
	queries := make([]string, 0, len(r.regexp.queries))
	if r.regexp.host != nil {
		if host, err = r.regexp.host.url(values); err != nil {
			return nil, err
		}
		scheme = "http"
		if r.buildScheme != "" {
			scheme = r.buildScheme
		}
	}
	if r.regexp.path != nil {
		if path, err = r.regexp.path.url(values); err != nil {
			return nil, err
		}
	}
	for _, q := range r.regexp.queries {
		var query string
		if query, err = q.url(values); err != nil {
			return nil, err
		}
		queries = append(queries, query)
	}
	return &url.URL{
		Scheme:   scheme,
		Host:     host,
		Path:     path,
		RawQuery: strings.Join(queries, "&"),
	}, nil
}

// URLHost builds the host part of the URL for a route. See Route.URL().
//
// The route must have a host defined.
func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.regexp.host == nil {
		return nil, errors.New("mux: route doesn't have a host")
	}
	values, err := r.prepareVars(pairs...)
	if err != nil {
		return nil, err
	}
	host, err := r.regexp.host.url(values)
	if err != nil {
		return nil, err
	}
	u := &url.URL{
		Scheme: "http",
		Host:   host,
	}
	if r.buildScheme != "" {
		u.Scheme = r.buildScheme
	}
	return u, nil
}

// URLPath builds the path part of the URL for a route. See Route.URL().
//
// The route must have a path defined.
func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.regexp.path == nil {
		return nil, errors.New("mux: route doesn't have a path")
	}
	values, err := r.prepareVars(pairs...)
	if err != nil {
		return nil, err
	}
	path, err := r.regexp.path.url(values)
	if err != nil {
		return nil, err
	}
	return &url.URL{
		Path: path,
	}, nil
}

// GetPathTemplate returns the template used to build the
// route match.
// This is useful for building simple REST API documentation and for instrumentation
// against third-party services.
// An error will be returned if the route does not define a path.
func (r *Route) GetPathTemplate() (string, error) {
	if r.err != nil {
		return "", r.err
	}
	if r.regexp.path == nil {
		return "", errors.New("mux: route doesn't have a path")
	}
	return r.regexp.path.template, nil
}

// GetPathRegexp returns the expanded regular expression used to match route path.
// This is useful for building simple REST API documentation and for instrumentation
// against third-party services.
// An error will be returned if the route does not define a path.
func (r *Route) GetPathRegexp() (string, error) {
	if r.err != nil {
		return "", r.err
	}
	if r.regexp.path == nil {
		return "", errors.New("mux: route does not have a path")
	}
	return r.regexp.path.regexp.String(), nil
}

// GetQueriesRegexp returns the expanded regular expressions used to match the
// route queries.
// This is useful for building simple REST API documentation and for instrumentation
// against third-party services.
// An error will be returned if the route does not have queries.
func (r *Route) GetQueriesRegexp() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.regexp.queries == nil {
		return nil, errors.New("mux: route doesn't have queries")
	}
	queries := make([]string, 0, len(r.regexp.queries))
	for _, query := range r.regexp.queries {
		queries = append(queries, query.regexp.String())
	}
	return queries, nil
}

// GetQueriesTemplates returns the templates used to build the
// query matching.
// This is useful for building simple REST API documentation and for instrumentation
// against third-party services.
// An error will be returned if the route does not define queries.
func (r *Route) GetQueriesTemplates() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.regexp.queries == nil {
		return nil, errors.New("mux: route doesn't have queries")
	}
	queries := make([]string, 0, len(r.regexp.queries))
	for _, query := range r.regexp.queries {
		queries = append(queries, query.template)
	}
	return queries, nil
}

// GetMethods returns the methods the route matches against
// This is useful for building simple REST API documentation and for instrumentation
// against third-party services.
// An error will be returned if route does not have methods.
func (r *Route) GetMethods() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	for _, m := range r.matchers {
		if methods, ok := m.(methodMatcher); ok {
			return []string(methods), nil
		}
	}
	return nil, errors.New("mux: route doesn't have methods")
}

// GetHostTemplate returns the template used to build the
// route match.
// This is useful for building simple REST API documentation and for instrumentation
// against third-party services.
// An error will be returned if the route does not define a host.
func (r *Route) GetHostTemplate() (string, error) {
	if r.err != nil {
		return "", r.err
	}
	if r.regexp.host == nil {
		return "", errors.New("mux: route doesn't have a host")
	}
	return r.regexp.host.template, nil
}

// GetVarNames returns the names of all variables added by regexp matchers
// These can be used to know which route variables should be passed into r.URL()
func (r *Route) GetVarNames() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	var varNames []string
	if r.regexp.host != nil {
		varNames = append(varNames, r.regexp.host.varsN...)
	}
	if r.regexp.path != nil {
		varNames = append(varNames, r.regexp.path.varsN...)
	}
	for _, regx := range r.regexp.queries {
		varNames = append(varNames, regx.varsN...)
	}
	return varNames, nil
}

// prepareVars converts the route variable pairs into a map. If the route has a
// BuildVarsFunc, it is invoked.
func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
	m, err := mapFromPairsToString(pairs...)
	if err != nil {
		return nil, err
	}
	return r.buildVars(m), nil
}

func (r *Route) buildVars(m map[string]string) map[string]string {
	if r.buildVarsFunc != nil {
		m = r.buildVarsFunc(m)
	}
	return m
}
package mux

import (
	"net/http"
	"strings"
)

// MiddlewareFunc is a function which receives an http.Handler and returns another http.Handler.
// Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed
// to it, and then calls the handler passed as parameter to the MiddlewareFunc.
type MiddlewareFunc func(http.Handler) http.Handler

// middleware interface is anything which implements a MiddlewareFunc named Middleware.
type middleware interface {
	Middleware(handler http.Handler) http.Handler
}

// Middleware allows MiddlewareFunc to implement the middleware interface.
func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler {
	return mw(handler)
}

// Use appends a MiddlewareFunc to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.
func (r *Router) Use(mwf ...MiddlewareFunc) {
	for _, fn := range mwf {
		r.middlewares = append(r.middlewares, fn)
	}
}

// useInterface appends a middleware to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.
func (r *Router) useInterface(mw middleware) {
	r.middlewares = append(r.middlewares, mw)
}

// RouteMiddleware -------------------------------------------------------------

// Use appends a MiddlewareFunc to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Route. Route middleware are executed after the Router middleware but before the Route handler.
func (r *Route) Use(mwf ...MiddlewareFunc) *Route {
	for _, fn := range mwf {
		r.middlewares = append(r.middlewares, fn)
	}

	return r
}

// useInterface appends a MiddlewareFunc to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Route. Route middleware are executed after the Router middleware but before the Route handler.
func (r *Route) useInterface(mw middleware) {
	r.middlewares = append(r.middlewares, mw)
}

// CORSMethodMiddleware automatically sets the Access-Control-Allow-Methods response header
// on requests for routes that have an OPTIONS method matcher to all the method matchers on
// the route. Routes that do not explicitly handle OPTIONS requests will not be processed
// by the middleware. See examples for usage.
func CORSMethodMiddleware(r *Router) MiddlewareFunc {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
			allMethods, err := getAllMethodsForRoute(r, req)
			if err == nil {
				for _, v := range allMethods {
					if v == http.MethodOptions {
						w.Header().Set("Access-Control-Allow-Methods", strings.Join(allMethods, ","))
					}
				}
			}

			next.ServeHTTP(w, req)
		})
	}
}

// getAllMethodsForRoute returns all the methods from method matchers matching a given
// request.
func getAllMethodsForRoute(r *Router, req *http.Request) ([]string, error) {
	var allMethods []string

	for _, route := range r.routes {
		var match RouteMatch
		if route.Match(req, &match) || match.MatchErr == ErrMethodMismatch {
			methods, err := route.GetMethods()
			if err != nil {
				return nil, err
			}

			allMethods = append(allMethods, methods...)
		}
	}

	return allMethods, nil
}

======

------------------
ChatGPT:


Let's create the unit tests for the provided mux.go file to increase the code coverage. Here's the initial set of unit tests:

go
Copy code
package mux

import (
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestNewRouter(t *testing.T) {
	r := NewRouter()
	if r == nil {
		t.Fatal("NewRouter() returned nil")
	}
}

func TestRouter_Get(t *testing.T) {
	r := NewRouter()
	route := r.NewRoute().Name("testRoute")
	if route == nil {
		t.Fatal("NewRoute().Name() returned nil")
	}

	gotRoute := r.Get("testRoute")
	if gotRoute != route {
		t.Fatalf("Get() = %v; want %v", gotRoute, route)
	}
}

func TestRouter_ServeHTTP(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	req, err := http.NewRequest("GET", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusOK {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusOK)
	}
}

func TestRouter_StrictSlash(t *testing.T) {
	r := NewRouter().StrictSlash(true)
	if !r.strictSlash {
		t.Fatal("StrictSlash() did not set the strictSlash field to true")
	}

	r = NewRouter().StrictSlash(false)
	if r.strictSlash {
		t.Fatal("StrictSlash() did not set the strictSlash field to false")
	}
}

func TestRouter_SkipClean(t *testing.T) {
	r := NewRouter().SkipClean(true)
	if !r.skipClean {
		t.Fatal("SkipClean() did not set the skipClean field to true")
	}

	r = NewRouter().SkipClean(false)
	if r.skipClean {
		t.Fatal("SkipClean() did not set the skipClean field to false")
	}
}

func TestRouter_OmitRouteFromContext(t *testing.T) {
	r := NewRouter().OmitRouteFromContext(true)
	if !r.omitRouteFromContext {
		t.Fatal("OmitRouteFromContext() did not set the omitRouteFromContext field to true")
	}

	r = NewRouter().OmitRouteFromContext(false)
	if r.omitRouteFromContext {
		t.Fatal("OmitRouteFromContext() did not set the omitRouteFromContext field to false")
	}
}

func TestRouter_OmitRouterFromContext(t *testing.T) {
	r := NewRouter().OmitRouterFromContext(true)
	if !r.omitRouterFromContext {
		t.Fatal("OmitRouterFromContext() did not set the omitRouterFromContext field to true")
	}

	r = NewRouter().OmitRouterFromContext(false)
	if r.omitRouterFromContext {
		t.Fatal("OmitRouterFromContext() did not set the omitRouterFromContext field to false")
	}
}

func TestRouter_UseEncodedPath(t *testing.T) {
	r := NewRouter().UseEncodedPath()
	if !r.useEncodedPath {
		t.Fatal("UseEncodedPath() did not set the useEncodedPath field to true")
	}
}

func TestRouter_Match(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {}).Methods("GET")

	req, err := http.NewRequest("GET", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	var match RouteMatch
	if !r.Match(req, &match) {
		t.Fatal("Match() did not find a matching route")
	}
	if match.MatchErr != nil {
		t.Fatalf("Match() returned an error: %v", match.MatchErr)
	}
	if match.Handler == nil {
		t.Fatal("Match() did not return a handler")
	}
}

func TestMethodNotAllowedHandler(t *testing.T) {
	handler := methodNotAllowedHandler()

	req, err := http.NewRequest("POST", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	handler.ServeHTTP(rr, req)

	if status := rr.Code; status != http.StatusMethodNotAllowed {
		t.Errorf("handler returned wrong status code: got %v want %v", status, http.StatusMethodNotAllowed)
	}
}

func TestCleanPath(t *testing.T) {
	tests := []struct {
		path string
		want string
	}{
		{"/", "/"},
		{"//", "/"},
		{"/../", "/"},
		{"/a/b/../c", "/a/c"},
		{"/a/b/./c", "/a/b/c"},
		{"/a//b/c/", "/a/b/c/"},
	}

	for _, tt := range tests {
		got := cleanPath(tt.path)
		if got != tt.want {
			t.Errorf("cleanPath(%q) = %v; want %v", tt.path, got, tt.want)
		}
	}
}

func TestReplaceURLPath(t *testing.T) {
	u, err := url.Parse("http://example.com/foo")
	if err != nil {
		t.Fatal(err)
	}

	newPath := "/bar"
	want := "http://example.com/bar"
	got := replaceURLPath(u, newPath)

	if got != want {
		t.Errorf("replaceURLPath() = %v; want %v", got, want)
	}
}

func TestCheckPairs(t *testing.T) {
	_, err := checkPairs("key1", "value1", "key2")
	if err == nil {
		t.Fatal("checkPairs() did not return an error for odd number of pairs")
	}

	_, err = checkPairs("key1", "value1", "key2", "value2")
	if err != nil {
		t.Fatalf("checkPairs() returned an error for even number of pairs: %v", err)
	}
}

func TestMapFromPairsToString(t *testing.T) {
	m, err := mapFromPairsToString("key1", "value1", "key2", "value2")
	if err != nil {
		t.Fatalf("mapFromPairsToString() returned an error: %v", err)
	}
	if m["key1"] != "value1" || m["key2"] != "value2" {
		t.Fatalf("mapFromPairsToString() = %v; want map[key1:value1 key2:value2]", m)
	}
}

func TestMapFromPairsToRegex(t *testing.T) {
	m, err := mapFromPairsToRegex("key1", "^value1$", "key2", "^value2$")
	if err != nil {
		t.Fatalf("mapFromPairsToRegex() returned an error: %v", err)
	}
	if !m["key1"].MatchString("value1") || !m["key2"].MatchString("value2") {
		t.Fatalf("mapFromPairsToRegex() did not return expected regex matchers")
	}
}

func TestMatchInArray(t *testing.T) {
	arr := []string{"one", "two", "three"}
	if !matchInArray(arr, "two") {
		t.Fatal("matchInArray() did not find the value in the array")
	}
	if matchInArray(arr, "four") {
		t.Fatal("matchInArray() found a value that should not be in the array")
	}
}

func TestMatchMapWithString(t *testing.T) {
	toCheck := map[string]string{"Content-Type": "application/json"}
	toMatch := map[string][]string{"Content-Type": {"application/json", "text/plain"}}
	if !matchMapWithString(toCheck, toMatch, true) {
		t.Fatal("matchMapWithString() did not find the key/value pair")
	}
	toCheck = map[string]string{"Content-Type": "application/xml"}
	if matchMapWithString(toCheck, toMatch, true) {
		t.Fatal("matchMapWithString() found a key/value pair that should not exist")
	}
}

func TestMatchMapWithRegex(t *testing.T) {
	toCheck := map[string]*regexp.Regexp{"Content-Type": regexp.MustCompile(`application/.*`)}
	toMatch := map[string][]string{"Content-Type": {"application/json", "application/xml"}}
	if !matchMapWithRegex(toCheck, toMatch, true) {
		t.Fatal("matchMapWithRegex() did not find the key/value pair with regex")
	}
	toCheck = map[string]*regexp.Regexp{"Content-Type": regexp.MustCompile(`text/.*`)}
	if matchMapWithRegex(toCheck, toMatch, true) {
		t.Fatal("matchMapWithRegex() found a key/value pair with regex that should not exist")
	}
}


These tests cover the primary functionalities of the Router and its methods. They should be added to a test file named mux_test.go in the same directory as your mux.go file. This suite of tests will help improve the overall code coverage of your package. If you have any specific parts of the code you want to focus on or further extend, let me know!
------------------
You:


Can you write additional test on top of these?
------------------
ChatGPT:


Sure! Here are some additional tests that cover more functionalities and edge cases of the mux.go file:

go
Copy code
package mux

import (
	"context"
	"net/http"
	"net/url"
	"regexp"
	"testing"
)

func TestRouter_NotFoundHandler(t *testing.T) {
	r := NewRouter()
	r.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("Not Found"))
	})

	req, err := http.NewRequest("GET", "/not-exist", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusNotFound {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusNotFound)
	}
	if rr.Body.String() != "Not Found" {
		t.Fatalf("ServeHTTP() body = %v; want %v", rr.Body.String(), "Not Found")
	}
}

func TestRouter_MethodNotAllowedHandler(t *testing.T) {
	r := NewRouter()
	r.MethodNotAllowedHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusMethodNotAllowed)
		w.Write([]byte("Method Not Allowed"))
	})

	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	}).Methods("GET")

	req, err := http.NewRequest("POST", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusMethodNotAllowed {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusMethodNotAllowed)
	}
	if rr.Body.String() != "Method Not Allowed" {
		t.Fatalf("ServeHTTP() body = %v; want %v", rr.Body.String(), "Method Not Allowed")
	}
}

func TestVars(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test/{var}", func(w http.ResponseWriter, r *http.Request) {
		vars := Vars(r)
		if vars["var"] != "value" {
			t.Errorf("Vars() = %v; want %v", vars["var"], "value")
		}
	})

	req, err := http.NewRequest("GET", "/test/value", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)
}

func TestCurrentRoute(t *testing.T) {
	r := NewRouter()
	route := r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		currentRoute := CurrentRoute(r)
		if currentRoute == nil {
			t.Error("CurrentRoute() = nil; want non-nil")
		}
		if currentRoute.GetName() != "testRoute" {
			t.Errorf("CurrentRoute().GetName() = %v; want %v", currentRoute.GetName(), "testRoute")
		}
	}).Name("testRoute")

	req, err := http.NewRequest("GET", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)
	if route.GetName() != "testRoute" {
		t.Fatalf("Route name = %v; want %v", route.GetName(), "testRoute")
	}
}

func TestCurrentRouter(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		currentRouter := CurrentRouter(r)
		if currentRouter == nil {
			t.Error("CurrentRouter() = nil; want non-nil")
		}
		if len(currentRouter.routes) != 1 {
			t.Errorf("CurrentRouter().routes = %v; want %v", len(currentRouter.routes), 1)
		}
	})

	req, err := http.NewRequest("GET", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)
}

func TestRoute_Headers(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	}).Headers("X-Test-Header", "test-value")

	req, err := http.NewRequest("GET", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}
	req.Header.Set("X-Test-Header", "test-value")

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusOK {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusOK)
	}
}

func TestRoute_Host(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	}).Host("example.com")

	req, err := http.NewRequest("GET", "http://example.com/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusOK {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusOK)
	}
}

func TestRoute_Queries(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	}).Queries("foo", "bar")

	req, err := http.NewRequest("GET", "/test?foo=bar", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusOK {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusOK)
	}
}

func TestRoute_Schemes(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	}).Schemes("https")

	req, err := http.NewRequest("GET", "https://example.com/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusOK {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusOK)
	}
}

func TestCORSMethodMiddleware(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {}).Methods("GET", "POST")

	r.Use(CORSMethodMiddleware(r))

	req, err := http.NewRequest("OPTIONS", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if allowMethods := rr.Header().Get("Access-Control-Allow-Methods"); allowMethods != "GET,POST" {
		t.Fatalf("Access-Control-Allow-Methods = %v; want %v", allowMethods, "GET,POST")
	}
}


These additional tests cover more features and edge cases of the mux package, including handling of headers, hosts, queries, schemes, CORS, and context-related functions. Add these tests to your mux_test.go file to further increase the code coverage. If there are any other specific areas or functions you want to cover, let me know!
------------------
You:


=== RUN   TestGPTCORSMethodMiddleware
    mux_test.go:449: Access-Control-Allow-Methods = ; want GET,POST
--- FAIL: TestGPTCORSMethodMiddleware (0.00s)

------------------
ChatGPT:


It looks like the Access-Control-Allow-Methods header was not set correctly. This might be due to the route not having an OPTIONS method matcher or the CORS middleware not working as expected. Let me correct the test and the implementation to ensure the CORS middleware is properly tested:

Ensure the route has an OPTIONS method matcher.
Add a custom method to set the Access-Control-Allow-Methods header.

Here's the revised code:

go
Copy code
package mux

import (
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestCORSMethodMiddleware(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {}).Methods("GET", "POST")

	r.Use(CORSMethodMiddleware(r))

	// Ensure OPTIONS method is handled by the router
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {}).Methods("OPTIONS")

	req, err := http.NewRequest("OPTIONS", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if allowMethods := rr.Header().Get("Access-Control-Allow-Methods"); allowMethods != "GET,POST,OPTIONS" {
		t.Fatalf("Access-Control-Allow-Methods = %v; want %v", allowMethods, "GET,POST,OPTIONS")
	}
}

// Additional tests for completeness

func TestRouter_ServeHTTP_NotFound(t *testing.T) {
	r := NewRouter()

	req, err := http.NewRequest("GET", "/notfound", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusNotFound {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusNotFound)
	}
}

func TestRouter_ServeHTTP_MethodNotAllowed(t *testing.T) {
	r := NewRouter()
	r.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {}).Methods("GET")

	req, err := http.NewRequest("POST", "/test", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	if rr.Code != http.StatusMethodNotAllowed {
		t.Fatalf("ServeHTTP() = %v; want %v", rr.Code, http.StatusMethodNotAllowed)
	}
}


In this revised test, we add an OPTIONS method matcher to the route. This ensures that the router can handle OPTIONS requests, which is necessary for the CORS middleware to set the Access-Control-Allow-Methods header correctly. Additionally, we check for GET,POST,OPTIONS as the expected value since the OPTIONS method is also matched.
------------------
